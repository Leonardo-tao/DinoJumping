{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"game\"\n};\nconst _hoisted_2 = [\"width\", \"height\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", {\n    id: \"canvas\",\n    width: $data.canvasWidth,\n    height: $data.canvasHeight\n  }, null, 8 /* PROPS */, _hoisted_2)]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createElementVNode","id","width","$data","canvasWidth","height","canvasHeight","_hoisted_2"],"sources":["E:\\code\\Web\\dino\\src\\components\\game.vue"],"sourcesContent":["<template>\n  <div class=\"game\">\n    <canvas id=\"canvas\" :width=\"canvasWidth\" :height=\"canvasHeight\" />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'playGame',\n  data() {\n    return {\n      ctx: null,\n      canvasWidth: 1200,\n      canvasHeight: 150,\n      speed: 0,                   // 画面移动速度\n      groundX: 0,                 // 地面坐标\n      isRunning: false,           // 地面是否开始移动\n      currentLeg: 'left',         // 当前小恐龙腿的状态\n      legTimer: null,             // 控制左右脚切换的定时器\n      pace: 300,                  // 步频\n      isJumping: false,           // 跳跃状态\n      jumpHeight: 0,              // 当前跳跃高度\n      gravity: 1.3,               // 重力加速度\n      barriers: [],\n      clouds: [],\n      barriers_list: [],\n      lastBarrierX: 1200,\n      lastCloudX: 1200,\n      loadedImages: {},           // 存储加载后的图片\n      images: {\n        initial: \"initial\",\n        start: \"start\",\n        die: \"die\",\n        ground: \"ground\",\n        left: \"runl\",\n        right: \"runr\",\n        jump: \"start\",\n        bird_up: \"bird_up\", \n        bird_down: \"bird_down\",\n        treeS: \"treeS\",\n        treeB: \"treeB\",\n        treeG: \"treeG\",\n        endText: \"endText\",\n        restart: \"restart\",\n        cloud: \"cloud\",\n        \"0\":\"0\",\n        \"1\":\"1\",\n        \"2\":\"2\",\n        \"3\":\"3\",\n        \"4\":\"4\",\n        \"5\":\"5\",\n        \"6\":\"6\",\n        \"7\":\"7\",\n        \"8\":\"8\",\n        \"9\":\"9\"\n      }\n    }\n  },\n  computed: {\n    groundW: function() {return this.loadedImages['ground'].width},\n    groundH: function() {return this.loadedImages['ground'].height},\n    dinoW: function() {return this.loadedImages['initial'].width},\n    dinoH: function() {return this.loadedImages['initial'].height},\n    groundY: function() {\n      return this.canvasHeight - this.loadedImages['ground'].height - this.dinoH\n    }\n  },\n  methods: {\n    // 绘制图片\n    drawPic(pic, x, y, w, h) {\n      let img = this.loadedImages[pic] // 使用已加载的图片\n\n      if (!img) return // 如果图片尚未加载，直接返回\n\n      if (w === undefined) w = img.width\n      if (h === undefined) h = img.height\n      if (y === undefined) y = this.groundY\n      if (x === undefined) x = 0\n\n      this.ctx.drawImage(img, x, y, w, h)\n    },\n    // 更新地面位置\n    updateGroundPosition() {\n      this.groundX -= this.speed\n\n      if (this.groundX <= -this.canvasWidth) {\n        this.groundX = 0\n      }\n    },\n    handleKeyDown(e) {\n      if (e.key === 'Enter' && !this.isRunning) {\n        this.isRunning = true\n        this.speed = 1\n        this.play() // 启动动画\n      }\n\n      if (this.isRunning && e.key === ' ' && !this.isJumping) { // 按下空格键\n        this.isJumping = true // 标记为正在跳跃\n        this.jumpHeight = 0 // 重置跳跃高度\n      }\n    },\n    // 加速函数\n    accelerate() {\n      this.speed += 0.001\n      this.pace -= 0.1\n    },\n    // 跳跃\n    updateJump() {\n      if (this.isJumping) {\n        this.jumpHeight += this.gravity // 增加跳跃高度\n        \n        // 当跳跃达到一定高度后，开始下降\n        if (this.jumpHeight > 70) { // 设定跳跃高度阈值\n          this.gravity = -1 // 反向重力，实现下降\n        }\n        \n        // 检查是否回到地面\n        if (this.jumpHeight <= 0) {\n          this.jumpHeight = 0 // 重置高度\n          this.isJumping = false // 跳跃结束\n          this.gravity = 1.3 // 重置重力加速度\n        }\n      }\n    },\n    initialize(){\n      // 绘制地面和小恐龙\n      this.drawPic('ground', this.groundX, this.canvasHeight - this.groundH - 10)\n      this.drawPic('start', 10, this.groundY)  // 根据跳跃状态调整y坐标\n    },\n    // 开始跑步，地面移动 + 小恐龙切换左右脚\n    play() {\n      this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight)\n      // 绘制地面和小恐龙\n      this.drawBarriers()\n      this.drawClouds()\n      this.drawPic('ground', this.groundX, this.canvasHeight - this.groundH - 10)\n      this.drawPic('ground', this.groundX + this.canvasWidth, this.canvasHeight - this.groundH - 10)\n      const dinoY = this.isJumping ? (this.groundY - this.jumpHeight) : this.groundY\n\n      this.drawPic(this.isRunning ? this.currentLeg : 'start', 10,dinoY)  // 根据跳跃状态调整y坐标\n      // 开始切换左右脚\n      this.legTimer = setInterval(() => {\n        this.currentLeg = this.currentLeg === 'left' ? 'right' : 'left'\n      }, this.pace) // 每300ms切换一次\n\n      // 地面开始移动\n      this.updateGroundPosition() // 地面移动\n      this.accelerate() // 设置加速\n      this.updateJump() // 更新跳跃\n\n      // 每隔一定时间生成障碍物\n      if (this.barriers.length === 0 || Math.random() < 0.02) { // 设定生成概率\n        this.setBarrier()\n      }\n      // 每隔一定时间生成云\n      if (this.clouds.length === 0 || Math.random() < 0.2) { // 设定生成概率\n        this.setCloud()\n      }\n\n      // 请求下一帧动画\n      requestAnimationFrame(this.play.bind(this))\n    },\n    // 设置障碍物\n    setBarrier() {\n      const minGap = 300 // 障碍物的间隔\n      const maxGap = 800 // 障碍物的间隔\n      const x = this.lastBarrierX + Math.random() * (maxGap - minGap) + minGap // 随机生成 x 坐标\n      const height = this.groundY\n      this.barriers.push({ x, height }) // 将障碍物添加到数组中\n      this.lastBarrierX = x\n    },\n    // 绘制障碍物\n    drawBarriers() {\n      this.barriers.forEach(barrier => {\n        this.drawPic('treeS', barrier.x, barrier.height)\n        barrier.x -= this.speed // 更新障碍物位置\n      })\n      // 移除超出画布的障碍物\n      this.barriers = this.barriers.filter(barrier => barrier.x + 50 > 0)\n    },\n    // 设置障碍物\n    setCloud() {\n      const minGap = 300 \n      const maxGap = 800 \n      const x = this.lastCloudX + Math.random() * (maxGap - minGap) + minGap // 随机生成 x 坐标\n      const height = Math.random() * 50 + 20\n      this.clouds.push({ x, height })\n      this.lastCloudX = x\n    },\n    // 绘制障碍物\n    drawClouds() {\n      this.clouds.forEach(cloud => {\n        this.drawPic('cloud', cloud.x, cloud.height)\n        cloud.x -= this.speed // 更新障碍物位置\n      })\n      // 移除超出画布的障碍物\n      this.clouds = this.clouds.filter(cloud => cloud.x + 50 > 0)\n    },\n  },\n  mounted() {\n    this.ctx = document.getElementById('canvas').getContext(\"2d\")\n\n    // 预加载图片资源\n    const imagePromises = Object.entries(this.images).map(([key, imageSrc]) => {\n      return new Promise((resolve, reject) => {\n        const img = new Image()\n        img.src = require(`/src/assets/images/${imageSrc}.png`)\n\n        img.onload = () => {\n          this.loadedImages[key] = img // 存储已加载的图片\n          resolve()\n        }\n\n        img.onerror = () => {\n          console.error(`加载图片失败: ${img.src}`)\n          reject()\n        }\n      })\n    })\n    \n    // 确保所有图片资源加载完成后再启动动画\n    Promise.all(imagePromises)\n    .then(() => {\n        this.initialize()       // 初始化\n        window.addEventListener('keydown', this.handleKeyDown)  // 监听键盘事件\n      })\n      .catch(error => {\n        console.error(\"图片加载失败：\", error)\n      })\n  },\n  unmounted() {\n    if (this.legTimer) {\n      clearInterval(this.legTimer)\n    }\n    // window.removeEventListener('keydown', this.handleKeyDown)\n  }\n\n}\n</script>\n\n<style scoped>\n  #canvas {\n    background-color: #fff;\n  }\n</style>\n"],"mappings":";;EACOA,KAAK,EAAC;AAAM;mBADnB;;uBACEC,mBAAA,CAEM,OAFNC,UAEM,GADJC,mBAAA,CAAkE;IAA1DC,EAAE,EAAC,QAAQ;IAAEC,KAAK,EAAEC,KAAA,CAAAC,WAAW;IAAGC,MAAM,EAAEF,KAAA,CAAAG;0BAFtDC,UAAA,E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}